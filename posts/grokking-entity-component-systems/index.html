<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta itemprop=name content="Grokking Entity-Component-Systems"><meta itemprop=description content="I&rsquo;ve spent many commutes in the last few months learning the intricacies of Specs, an entity-component-system (ECS) written in Rust and, to be more broad, ECSs in general. ECSs have proved to be a much deeper topic than I had initially anticipated. Now I&rsquo;d like to explain my findings in order to solidify that knowledge.
ECSs are a decoupling pattern. They&rsquo;re most frequently seen in game development where we often have many similar yet distinct types of game objects."><meta itemprop=datePublished content="2018-01-03T00:00:00+00:00"><meta itemprop=dateModified content="2018-01-03T00:00:00+00:00"><meta itemprop=wordCount content="1787"><meta itemprop=keywords content="softdev,gamedev,"><meta property="og:title" content="Grokking Entity-Component-Systems"><meta property="og:description" content="I&rsquo;ve spent many commutes in the last few months learning the intricacies of Specs, an entity-component-system (ECS) written in Rust and, to be more broad, ECSs in general. ECSs have proved to be a much deeper topic than I had initially anticipated. Now I&rsquo;d like to explain my findings in order to solidify that knowledge.
ECSs are a decoupling pattern. They&rsquo;re most frequently seen in game development where we often have many similar yet distinct types of game objects."><meta property="og:type" content="article"><meta property="og:url" content="https://www.kwyse.com/posts/grokking-entity-component-systems/"><meta property="article:published_time" content="2018-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2018-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Grokking Entity-Component-Systems"><meta name=twitter:description content="I&rsquo;ve spent many commutes in the last few months learning the intricacies of Specs, an entity-component-system (ECS) written in Rust and, to be more broad, ECSs in general. ECSs have proved to be a much deeper topic than I had initially anticipated. Now I&rsquo;d like to explain my findings in order to solidify that knowledge.
ECSs are a decoupling pattern. They&rsquo;re most frequently seen in game development where we often have many similar yet distinct types of game objects."><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><title>Grokking Entity-Component-Systems</title><link rel=stylesheet href=https://www.kwyse.com/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin=anonymous></head><body id=page><header id=site-header class="animated slideInUp faster"><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://www.kwyse.com/>The Blog of Krishan Wyse</a></div><nav class="site-nav hide-in-mobile"><a href=https://www.kwyse.com/cv/>CV</a>
<a href=https://www.kwyse.com/posts/>Posts</a>
<a href=https://www.kwyse.com/euler-solutions/>Project Euler Solutions</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://github.com/kwyse/ target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/krishanwyse/ target=_blank rel="noopener me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://www.kwyse.com/cv/>CV</a></li><li><a href=https://www.kwyse.com/posts/>Posts</a></li><li><a href=https://www.kwyse.com/euler-solutions/>Project Euler Solutions</a></li></ul></div><main class="site-main section-inner animated fadeIn faster"><article class=thin><header class=post-header><div class=post-meta><span>3 Jan 2018</span></div><h1>Grokking Entity-Component-Systems</h1></header><div class=content><p>I&rsquo;ve spent many commutes in the last few months learning the intricacies of
<a href=https://github.com/slide-rs/specs>Specs</a>, an entity-component-system (ECS) written in Rust and, to be more broad,
ECSs in general. ECSs have proved to be a much deeper topic than I had initially
anticipated. Now I&rsquo;d like to explain my findings in order to solidify that
knowledge.</p><p>ECSs are a decoupling pattern. They&rsquo;re most frequently seen in game development
where we often have many similar yet distinct types of <em>game objects</em>. Games are
effectively giant state machines and it can be hard to create an object-oriented
hierarchy that represents this. ECSs instead implore the use of data-driven
programming, with components representing the data to be acted on, systems
acting on those components to mutate them, and entities linking components for
each game object.</p><h2 id=high-level-design>High level design<a href=#high-level-design class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>There isn&rsquo;t clear consensus on <em>how</em> one should go about building an
ECS. They&rsquo;re enough of a high-level concept that implementation details can be
optimised to a particular use case. But there are clear themes, which I&rsquo;ve
included here, as well as design decisions that I found particularly
interesting.</p><p>The first revelation is that entities needn&rsquo;t be fat. Entities represent a game
object, like the player. You may think a <em>player</em> object must be complex,
composed of many other objects like hardware input, a hit box for collision
detection, and a sprite. Not so. Instead it can be just a unique ID.</p><p>As for these other objects that compose a player, they are components. Ideally,
components should only contain primitive types. It is vital that we are able to
retrieve the component instance for a particular component and for a particular
entity efficiently (<em>O(1)</em>), because these operations will make up most of the
game loop, as you&rsquo;ll see shortly. We accomplish the first part by storing each
type of component in a different collection. For example, all positions for all
entities will be stored in one collection and all sprites will be stored in
another. How the second requirement is fulfilled depends on the underlying
storage medium.</p><p>For a map data structure, it&rsquo;s simple because lookup for a given ID (the entity
ID) will always be amortized to constant time complexity. But maps have
overhead. For example, the hashing function must be ran on every insertion and
lookup for hash maps.</p><p>For arrays, we could insert the entity at an index that matches its ID. The
problem here is that the array must be as large as the largest entity ID. This
brings a distinction between <em>hot</em> components which we&rsquo;ll likely have many of,
like entity positions, and <em>cold</em> components which we may only have a few of,
like the keyboard input context. In general, arrays are a better storage medium
for hot components and maps are better for cold components, though other data
structures exist and may suit your particular use case more. This binary
division may also not create enough granularity for your use case.</p><p>Efficient lookup is vital because we will need to iterate through these
collections in our systems. We could have a <em>MovementSystem</em> that adjusts an
entity&rsquo;s position based on its velocity. This system must iterate through all
components in the velocities collection (probably an array because we would
expect there to be many entities that have a velocity component) and join on the
indexes that also exist in the positions collection. Ideally the API should
seamlessly expose this join, because it&rsquo;s generic across all systems and all
components. All the system cares about is being provided components that it
needs to act upon that belong to the same entity. This keeps the system
small. It should only include the logic to mutate a position given a velocity.</p><p>Structuring the code this way gives a clear decoupling benefit. What may not be
as clear is the performance benefit. Remember that components should ideally
only contain primitive types, and appropriately abstracted components should be
as small as possible. This means their collections should also be small in terms
of memory. We can then take advantage of the CPU caches. If our position
component is simply a coordinate with two 64-bit floating point components, an
<em>x</em> component and a <em>y</em> component, we could have as many as a few thousand
position components and still fit comfortably in the L1 cache, not to mention
the L2 and L3 caches for more realistic collection sizes.</p><h2 id=a-rust-implementation-with-specs>A Rust implementation with Specs<a href=#a-rust-implementation-with-specs class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Specs relies on another crate called <a href=https://github.com/slide-rs/shred><code>shred</code></a>, used for shared resource
dispatching. This in turn relies on a crate called <a href=https://github.com/chris-morgan/mopa><code>mopa</code></a>. Let&rsquo;s start there and
work our way backwards.</p><p><code>mopa</code>, or <em>My Own Personal Any</em>, allows you to covert an object that implements
a certain trait into the concrete object, known as downcasting. This emulates
downcasting on the <a href=https://doc.rust-lang.org/std/any/trait.Any.html><code>Any</code></a> trait in the Rust standard library.</p><p><code>shred</code> uses this for storing arbitrarily-typed structs. What we were calling a
component above, <code>shred</code> calls a <em>resource</em>. Its <code>Resource</code> trait is implemented
for all types that adhere to Rust&rsquo;s borrowing model, all those that implement
<code>Any + Send + Sync</code>, but this <code>Any</code> is <code>mopa</code>'s <code>Any</code>, not the standard library
<code>Any</code>, which means we can only downcast our own <code>Resource</code> s, but that&rsquo;s all we
need. You can see this in the <a href=https://github.com/slide-rs/shred/blob/master/src/res/mod.rs><code>res</code></a> module of <code>shred</code>.</p><p>A neat optimisation is that <code>Resource</code> s are stored in a <code>FnvHashMap</code>. This uses
the <em>FNV</em> hashing algorithm instead of the default <em>SipHash</em> algorithm. The
former is faster when using smaller keys, but is less secure. This is perfectly
acceptable in this instance because our keys are just unsigned integers (wrapped
in <a href=https://doc.rust-lang.org/std/any/struct.TypeId.html><code>std::any::TypeId</code></a>, itself wrapped in <code>shred</code>'s <code>ResourceId</code>). Benchmarks can
be found <a href=http://cglab.ca/~abeinges/blah/hash-rs/>here</a>.</p><p><code>shred</code> revolves around its <code>Fetch</code> and <code>FetchMut</code> structs. These are
effectively wrappers for <a href=https://doc.rust-lang.org/std/cell/struct.Ref.html><code>Ref</code></a> and <a href=https://doc.rust-lang.org/std/cell/struct.RefMut.html><code>RefMut</code></a> from the standard library,
respectively. <code>Ref</code> and <code>RefMut</code> are in turn the wrappers for objects contained
within a <a href=https://doc.rust-lang.org/std/cell/struct.RefCell.html><code>RefCell</code></a> when it is <em>borrowed</em>.</p><p>=RefCell=s are used when we want to enforce Rust&rsquo;s borrowing rules at runtime
rather than compile time. These rules, at their core, are that we can only have
one mutable reference to an object at a time, or multiple immutable references
to it. As such, we can have only have one <code>FetchMut</code> reference to a resource at
a time, or multiple <code>Fetch</code> ones. When we want to read a component, we specify
a system with a <code>Fetch</code> of that same type. We do the same for components we want
to modify, but use <code>FetchMut</code> for those instead.</p><p>A really ergonomic feature of this API is that you declare the components a
system corresponds to with a tuple. This allows you to include as many read or
write resources in a system as you want&mldr; almost. There&rsquo;s a <a href=https://github.com/slide-rs/shred/blob/master/src/system.rs#L215><code>hard limit</code></a> of
26, though systems should never reach close to that number in practice.</p><p>That&rsquo;s the crux of how <code>shred</code> is working under the hood. Check the project&rsquo;s
<a href=https://github.com/slide-rs/shred/blob/master/README.md>README</a> for example usage.</p><p>Specs fine tunes this model specifically for ECSs. Its API uses terminology
that&rsquo;s more familiar. All structs that our systems want to work on must
implement the <code>Component</code> trait. The tuple that defines the components our
systems work on accepts <code>ReadStorage</code> and <code>WriteStorage</code> types instead of
<code>Fetch</code> and <code>FetchMut</code>. It also introduces different storage strategies like
<code>VecStorage</code> and <code>HashMapStorage</code>, with the same nuances described in the
previous section.</p><h2 id=demonstration>Demonstration<a href=#demonstration class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Theory only goes so far. We want a result. Let&rsquo;s follow along with the examples
above. We&rsquo;ll create an ECS that modifies an entity&rsquo;s position according to it&rsquo;s
velocity. Rather than just show numbers being affected, let&rsquo;s actually show the
entity moving across the screen. We&rsquo;ll use SDL2 for events, rendering and window
management.</p><p>The following application was built with these crates:</p><ul><li>sdl2 (0.31.0)</li><li>specs (0.10.0)</li><li>specs-derive (0.1.0)</li></ul><p>First we declare out components. This includes a sprite component that wraps
SDL2&rsquo;s <code>Rect</code> struct. SDL2 makes it easy to render =Rect=s to screen.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Component)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Position</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>y</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Component)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Velocity</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>y</span>: <span class=kt>f64</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Component)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Sprite</span><span class=p>(</span><span class=n>Rect</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Then we declare out systems. The first one is to update the position of an
entity given its velocity.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>MovementSystem</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>System</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MovementSystem</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>SystemData</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=w>
</span><span class=w>	</span><span class=n>Fetch</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>Duration</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>ReadStorage</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>Velocity</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>WriteStorage</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>Position</span><span class=o>&gt;</span><span class=w>
</span><span class=w>    </span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>run</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>data</span>: <span class=nc>Self</span>::<span class=n>SystemData</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>dt</span><span class=p>,</span><span class=w> </span><span class=n>velocities</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>positions</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>data</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>vel</span><span class=p>,</span><span class=w> </span><span class=n>pos</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=o>&amp;</span><span class=n>velocities</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>positions</span><span class=p>).</span><span class=n>join</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	    </span><span class=n>pos</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>vel</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>dt</span><span class=p>.</span><span class=n>subsec_nanos</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f64</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>1_000_000_000.0</span><span class=p>;</span><span class=w>
</span><span class=w>	    </span><span class=n>pos</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>vel</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>dt</span><span class=p>.</span><span class=n>subsec_nanos</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>f64</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mf>1_000_000_000.0</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This matches the logic described prior. The only difference is that we also
include a <em>delta time</em> input value. This represents the amount of time that has
passed from one frame to the next. We need this because we don&rsquo;t have control on
exactly when our function will be called again. We can aim for a target, say, 60
times per second, but we&rsquo;ll never hit that exactly. It may only be a few
milliseconds off here and there, but that adds up the longer the game is
running. Pretty quickly we would have vastly inaccurate positions if you don&rsquo;t
scale them like this! <a href=https://gafferongames.com/post/integration%5Fbasics/>Integration Basics</a> by Glenn Fiedler explains why this
happens.</p><p>The other system we need converts logical world coordinates to screen
coordinates.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>RenderSystem</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>System</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>RenderSystem</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>SystemData</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ReadStorage</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>Position</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>WriteStorage</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>Sprite</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>run</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>data</span>: <span class=nc>Self</span>::<span class=n>SystemData</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>positions</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>sprites</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>data</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>pos</span><span class=p>,</span><span class=w> </span><span class=n>sprite</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=o>&amp;</span><span class=n>positions</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>sprites</span><span class=p>).</span><span class=n>join</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	    </span><span class=n>sprite</span><span class=p>.</span><span class=mf>0.</span><span class=n>set_x</span><span class=p>((</span><span class=n>pos</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>PIXELS_PER_UNIT</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span><span class=w>	    </span><span class=n>sprite</span><span class=p>.</span><span class=mf>0.</span><span class=n>set_y</span><span class=p>((</span><span class=n>pos</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>PIXELS_PER_UNIT</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Using logical world units for an entity&rsquo;s position frees us from the details of
our rendering process. When it comes to rendering, we simply scale the position
by a constant factor to get screen coordinates, which is used by our sprite for
rendering.</p><p>Almost there. We now need to hook this all up to the <code>World</code>, which manages the
entities.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>world</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>World</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=n>world</span><span class=p>.</span><span class=n>add_resource</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=n>world</span><span class=p>.</span><span class=n>register</span>::<span class=o>&lt;</span><span class=n>Position</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=n>world</span><span class=p>.</span><span class=n>register</span>::<span class=o>&lt;</span><span class=n>Velocity</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=n>world</span><span class=p>.</span><span class=n>register</span>::<span class=o>&lt;</span><span class=n>Sprite</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>initial_pos</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Position</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>2.0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>2.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>initial_vel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Velocity</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mf>0.0</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>sprite</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Sprite</span><span class=p>(</span><span class=n>Rect</span>::<span class=n>new</span><span class=p>(</span><span class=w>
</span><span class=w>	</span><span class=p>(</span><span class=n>initial_pos</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>PIXELS_PER_UNIT</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=p>(</span><span class=n>initial_pos</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>PIXELS_PER_UNIT</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=mi>32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=mi>32</span><span class=w>
</span><span class=w></span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=n>world</span><span class=p>.</span><span class=n>create_entity</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>with</span><span class=p>(</span><span class=n>initial_pos</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>with</span><span class=p>(</span><span class=n>initial_vel</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>with</span><span class=p>(</span><span class=n>sprite</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>build</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>dispatcher</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>DispatcherBuilder</span>::<span class=n>new</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>MovementSystem</span><span class=p>,</span><span class=w> </span><span class=s>&#34;movement_system&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=p>[])</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>RenderSystem</span><span class=p>,</span><span class=w> </span><span class=s>&#34;render_system&#34;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=p>[</span><span class=s>&#34;movement_system&#34;</span><span class=p>])</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>build</span><span class=p>();</span><span class=w>
</span></code></pre></div><p>It&rsquo;s then just one line to update all of our entities.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=n>dispatcher</span><span class=p>.</span><span class=n>dispatch</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world</span><span class=p>.</span><span class=n>res</span><span class=p>);</span><span class=w>
</span></code></pre></div><p>Of course, we need some additional infrastructure around this. The above line
should belong in the application run loop. That loop should also contain input
handling and rendering to a hardware context.</p><p>You may be able to implement those as systems as well, but at some point you
will hit a boundary where the objects are too large. This will often be with
input and output. Rendering to screen is a complex process, and should probably
be done outside of the ECS. This demonstrates that ECSs are not appropriate for
the entire application, particularly on the boundaries, but still very useful
for internal logic that we have full control over.</p><p>If you would like to learn the details of run loops, check out <a href=https://gafferongames.com/post/fix%5Fyour%5Ftimestep/>Fix Your
Timestep!</a> It&rsquo;s probably the most quoted article on the subject and does a fine
job explaining the various approaches.</p><h2 id=results>Results<a href=#results class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p><a href=https://gist.github.com/kwyse/1d6be3de1c95d05502e10b6dba3cc6be>Gist of the source code</a></p><p>The above includes the simplest kind of run loop with a fixed time step of
1/60th of a second. The results are hopefully a white square moving across a
black abyss.</p><figure><img src=/images/grokking_ecs_result.gif></figure><p>There are many ways to improve this. You could use a more sophisticated run loop
that can handle variable time steps. Or you could use the parallel iterators
offered by Specs to improve performance. It&rsquo;s probably a good idea to better
define the boundaries of our ECS explicitly as well. Modularise all of that and
you have the beginnings of a game!</p></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://www.kwyse.com/tags/softdev>softdev</a></span><span class=tag><a href=https://www.kwyse.com/tags/gamedev>gamedev</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1787 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2018-01-03</p></footer></article><div class="post-nav thin"><a class=next-post href=https://www.kwyse.com/posts/twid-rss/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>This Week I Discovered: RSS</span></a>
<a class=prev-post href=https://www.kwyse.com/posts/twid-open-mw/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>This Week I Discovered: OpenMW</span></a></div><div id=comments class=thin></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2017–2020 <a href=https://www.kwyse.com/>Krishan Wyse</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://www.kwyse.com/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://www.kwyse.com/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin=anonymous></script></body></html>