title: Quest to Make a Personal Website
author: Krishan Wyse
date: 7 July, 2016
path: quest-to-build-personal-website
summary: The story of the humble beginnings of this very website

I have always wanted a blog. I have always wanted a homepage. I have a tendency to want to implement myself what I'm able to and what I understand. I find this benefits learning but can hamper productivity. Thankfully, a personal website is not something I'd put a deadline on, but also something I'd like to sink my teeth into for the long haul. What you see around this body of text is the (ever in progress) result of that endevour.

I started this website with the goal of passing on what I know. I learn by reading and then by experimenting on what I read about. I could probably attribute most of my current knowledge to the written word rather than other forms of teaching, and a large portion of that was presented as articles on the internet. To continue in that vain and spread knowledge are core objectives here.

But lets get to more concrete topics. We want to build a website. We need a server. We also need a front-end but we can just load up a static HTML page for the time being. A server requires work though. Either we use an existing solution (which we'd need to configure) or we build it. So... let's build it!

# Servers of Iron

First of all, a word on Rust. I **love** Rust. I've spent the last few years hopping from language to language before I finally settled on using Rust for my hobby coding. Rust has it's nuances and shortcomings, but it has massive potential is an absolute pleasure to work with. I hope I can portray some of that here.

If you need a primer on Rust, look no further than the [Rust book]. If you can follow the syntax below but aren't sure on project setup, the [Cargo docs] have you covered.

We're going to use a Rust library called [Iron]. Web development in Rust is [not exactly mature], but it's certainly not in its infancy. Iron is one of the older and more established frameworks. It's also rediculously easy to use:

```rust
let handle_landing_page = || Ok(Response::with(
    (status::Ok, "Hello, world!")
));

let mut router = Router::new();
router.get("/", handle_landing_page);

let url = "localhost:42451";
println!("Starting server at {}", url);
Iron::new(router).http(url).unwrap();
```

This code is defining a handler for our landing page as a closure. You would probably want it to be it's own function if it did anything more complex, but it demonstrates how to link things together. We next define our router which expects a GET request to the root page, and calls our handler whenever it recieves such a request. Next we state which server and port we want Iron to use, and initialize it to listen for requests there.

# Templating with Handlebars

Writing a hello world app never gets old, but we can do better with relative ease. The `iron-handlebars` crate adds support for the [Handlebars] templating language directly to Iron. Templating languages allow for dynamic content to be loaded into an otherwise static HTML page. The post you're reading now differs from others based on the URL entered, but the header and footer remain the same across blog posts. This templating promotes clean project structure and keeps things [DRY]. Adding it to our project is trivial:

```rust
// { ... Routing logic as above ... }
let handle_landing_page = || Ok(Response::with(
    (status::Ok, Template::new("landing", ()))
));

let mut router = Router::new();
router.get("/", handle_landing_page);

let mut templates = HandlebarsEngine::new();
templates.add(Box::new(DirectorySource::new("templates/", ".hbs")));
templates.reload().unwrap();

let mut chain = Chain::new(router);
chain.link_after(templates);

let url = "localhost:42451";
println!("Starting server at {}", url);
Iron::new(chain).http(url).unwrap();
```

We redefine our handler to load the template named `landing.hbs` instead of a static string. The empty tuple passed as the second argument will contain our template data, which will add in a moment. The fact that we can so easily change the containing argument from a static string to an instance of the `Template` class is one of the beauties of Rust. You may have noticed the `Response::with` function is taking just one argument: a tuple, not two (notice the double set of perentheses). If you look at the signature of the function, it takes a `Modifier`. The Iron crate itself implements this trait for strings, and the Handlebars crate implements it for its `Template` struct. This enables beautifully simple client code like above. 

Next, we add the directory we intend to store the templates (as `.hbs` files in this case). We then tell the Handlebars engine to actually read the files stored there with the reload call. The next statement introduces the `Chain`. I can't figure out exactly what a `Chain` is from [the docs], but essentially it allows us to chain together different components of our server (the router with the templates here). We can pass the chain in place of the router to the Iron constructor using the same trait mechanism used by `Response::with`.

A template is no better than static HTML if you don't populate it with data. Let's imagine we're creating a blog post listing:

```rust
let mut template_data = BTreeMap::new();
template_data.insert("posts", vec!["Post 1", "Post 2", "Post 3"] );
let handle_blog_list_page = || Ok(Response::with(
    (status::Ok, Template::new("landing", template_data))
));
```

The accompanying template may look like:

```html
{{#each posts}}
  <a href="/blog/{{post}}">{{post}}</a>
{{/each}}
```

You can surround the `each` block with static content that you don't want to change between blog posts.

# Getting to Grips with Flexbox and Sass

We have a few different views now, but they're pretty plain to look at. Let's fix that with some styling.
