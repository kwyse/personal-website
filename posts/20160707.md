title: Quest to Make a Personal Website
author: Krishan Wyse
date: 7 July, 2016
path: quest-to-build-personal-website
summary: The story of the humble beginnings of this very website

I have always wanted a blog. I have always wanted a homepage. I have a tendency to want to implement myself what I'm able to and what I understand. I find this benefits learning but can hamper productivity. Thankfully, a personal website is not something I'd put a deadline on, but also something I'd like to sink my teeth into for the long haul. What you see around this body of text is the (ever in progress) result of that endevour.

I started this website with the goal of passing on what I know. I learn by reading and then by experimenting on what I read about. I could probably attribute most of my current knowledge to the written word rather than other forms of teaching, and a large portion of that was presented as articles on the internet. To continue in that vain and spread knowledge are core objectives here.

But lets get to more concrete topics. We want to build a website. We need a server. We also need a front-end but we can just load up a static HTML page for the time being. A server requires work though. Either we use an existing solution (which we'd need to configure) or we build it. So... let's build it!

# Servers of Iron

First of all, a word on Rust. I *love* Rust. I've spent the last few years hopping from language to language before I finally settled on using Rust for my hobby coding. Rust has it's nuances and shortcomings, but it has massive potential is an absolute pleasure to work with. I hope I can portray some of that here.

If you need a primer on Rust, look no further than the [Rust book](https://doc.rust-lang.org/book/). If you can follow the syntax below but aren't sure on project setup, the [Cargo docs](http://doc.crates.io/guide.html) have you covered.

We're going to use a Rust library called [Iron](https://crates.io/crates/iron). Web development in Rust is [not extensively mature](http://www.arewewebyet.org/), it's certainly not in its infancy. Iron is one of the older and more established frameworks. It's also rediculously easy to use:

```rust
let handle_landing_page = || Ok(Response::with(
    (status::Ok, "Hello, world!")
));

let mut router = Router::new();
router.get("/", handle_landing_page);

let url = "localhost:42451";
println!("Starting server at {}", url);
Iron::new(router).http(url).unwrap();
```

This code is defining a handler for our landing page as a closure. You would probably want it to be it's own function if it did anything more complex, but it demonstrates how to link things together. We next define our router which expects a GET request to the root page, and calls our handler whenever it recieves such a request. Next we state which server and port we want Iron to use, and initialize it to listen for requests there.

# Templating with Handlebars

Writing a hello world app never gets old, but we can do better with relative ease. The [`handlebars-iron`](https://crates.io/crates/handlebars-iron) crate adds support for the [Handlebars](http://handlebarsjs.com/) templating language directly to Iron. Templating languages allow for dynamic content to be loaded into an otherwise static HTML page. The post you're reading now differs from others based on the URL entered, but the header and footer remain the same across blog posts. This templating promotes clean project structure and keeps things [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). Adding it to our project is trivial:

```rust
// { ... Routing logic as above ... }
let handle_landing_page = || Ok(Response::with(
    (status::Ok, Template::new("landing", ()))
));

let mut router = Router::new();
router.get("/", handle_landing_page);

let mut templates = HandlebarsEngine::new();
templates.add(Box::new(DirectorySource::new("templates/", ".hbs")));
templates.reload().unwrap();

let mut chain = Chain::new(router);
chain.link_after(templates);

let url = "localhost:42451";
println!("Starting server at {}", url);
Iron::new(chain).http(url).unwrap();
```

We redefine our handler to load the template named `landing.hbs` instead of a static string. The empty tuple passed as the second argument will contain our template data, which will add in a moment. The fact that we can so easily change the containing argument from a static string to an instance of the `Template` class is one of the beauties of Rust. You may have noticed the `Response::with` function is taking just one argument: a tuple, not two (notice the double set of perentheses). If you look at the signature of the function, it takes a `Modifier`. The Iron crate itself implements this trait for strings, and the Handlebars crate implements it for its `Template` struct. This enables beautifully simple client code like above. 

Next, we add the directory we intend to store the templates (as `.hbs` files in this case). We then tell the Handlebars engine to actually read the files stored there with the reload call. The next statement introduces the `Chain`. I can't figure out exactly what a `Chain` is from [the docs](http://ironframework.io/doc/iron/middleware/struct.Chain.html), but essentially it allows us to chain together different components of our server (the router with the templates here). We can pass the chain in place of the router to the Iron constructor using the same trait mechanism used by `Response::with`.

A template is no better than static HTML if you don't populate it with data. Let's imagine we're creating a blog post listing:

```rust
let mut template_data = BTreeMap::new();
template_data.insert("posts", vec!["Post 1", "Post 2", "Post 3"] );
let handle_blog_list_page = || Ok(Response::with(
    (status::Ok, Template::new("landing", template_data))
));
```

The accompanying template may look like:

```html
{{#each posts}}
  <a href="/blog/{{post}}">{{post}}</a>
{{/each}}
```

You can surround the `each` block with static content that you don't want to change between blog posts.

# Getting to Grips with Sass and Flexbox

We have a few different views now, but they're pretty plain to look at. Let's fix that with some styling. CSS is fairly basic markup. As a result, a number of preprocessors have come about, [Less](http://lesscss.org/) (of Bootstrap fame) and [Sass](http://sass-lang.com/) being the most renound. I chose to use Sass simply because of friends mentioning it before. The advantages compared to CSS are outlined in the [guide](http://sass-lang.com/guide), but these are some things that particularly stand out for me:

```sass
// _mixin.scss
@mixin border-radius($radius) {
  -webkit-border-radius: radius;
  -moz-border-radius: radius;
  -ms-border-radius: radius;
  -o-border-radius: radius;
  border-radius: radius;
}

// main.scss
@import 'mixin'
.box {
  @include border-radius: 50%;
}
```

This demonstrates two features of Sass: partials and mixins. Notice the leading underscore in the filename of the first file. This marks it as a partial for Sass and allows you to include its contents in other SCSS files with the `@import` statement, providing a nice way to split up selectors. Mixins offer a way to set multiple selectors with one selector, as shown above where we set the various vendor-prefixed selectors. You can do some really neat things within mixins. [This post](http://joshbroton.com/quick-fix-sass-mixins-for-css-keyframe-animations/) by Josh Broton illustrates a way to use CSS3 animations using more advanced form, complete with looping and conditional execution.

More fundamental than the preprocessor you use is how you structure your CSS, as this will dictate your site layout. I first dabbled a bit with web development during my first year of university and found getting a layout just right was quite tedious. There's numerous hacks to get around existing CSS limitations, but I couldn't find anything encouraged good practice from the start.

Then I found Flexbox. Flexbox went through some backwards-incompatible revisions in the early 2010s and subsequently lacked an acceptable level of browser support. Fortunately, it's considered stable today and has support from all major browsers. [Solved by Flexbox](https://philipwalton.github.io/solved-by-flexbox/) is a phenominal resource showing its power.

Let's demontrate by writing a footer than remains at the bottom of the page regardless of the amount (or lack thereof) of content in the middle of the page.

```sass
.body {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.content {
  flex-grow: 1;
}

.footer {
  flex-shrink: 0;
}
```

By specifying `display: flex`, we are saying we want `.body` to act as Flexbox container. Setting `flex-grow` to `1` for the central content on the page makes it use *all* remaining space available, and as we set our container use the `column` direction, it will use all remaining *vertical* space. `flex-shrink` is set to `0` for the footer to make it stay a consistent size (usually what you want).

# Useful Resources

Hopefully you now have an idea of how you can create a custom server and a templated and style front-end relatively easily using these technologies. They all served as the foundations for this website from the beginning. I came into this with very little web development knowledge beyond basic HTML and CSS, and have learnt much through creating the website thanks to the great resources online. Here are some highlights:

* [A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) - very useful reference for Flexbox selectors
* [W3Schools](http://www.w3schools.com/) - useful general reference for HTML and CSS
* [Iron framework docs](http://ironframework.io/doc/iron/index.html)
